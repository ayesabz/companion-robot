#pragma config(Sensor, in1,    analog1,        sensorAnalog)
#pragma config(Sensor, dgtl1,  limit,          sensorTouch)
#pragma config(Sensor, dgtl2,  limitBack1,     sensorTouch)
#pragma config(Sensor, dgtl3,  limitBack2,     sensorTouch)
#pragma config(Sensor, dgtl10, digital10,      sensorDigitalOut)
#pragma config(Sensor, dgtl11, digital11,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, digital12,      sensorDigitalOut)
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           armMotor,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "gotobeacon.c"

void armDown() {
	motor[port2] = 50;
	wait1Msec(1000);
}

void armUp() {
	motor[port2] = -50;
	wait1Msec(1000);
}

void moveArm() {
	motor[port2] = 50;
	wait1Msec(1000);
	motor[port2] = -50;
	wait1Msec(1000);
	motor[port2] = 0;
}

void goToBeacon() {
	while (SensorValue(limit) != 1) {
		ReadPD();
		Find_max();
		Move();
	}
	motor[port1] = 0;
	motor[port10] = 0;
}

void escape() {

	int speed = backward_speed, spin_time = 1000, reverse_time = 1000;

	if ((SensorValue(limitBack1) == 0) && (SensorValue(limitBack2) == 0)) {
		motor[port1] = speed;
		motor[port10] = -speed;
	}

	else if ((SensorValue(limitBack2) == 1) && (SensorValue(limitBack1) == 0)) {
		motor[port1] = -speed;
		motor[port10] = speed;
		wait1Msec(reverse_time);

		motor[port1] = -speed;
		motor[port10] = -speed;
		wait1Msec(spin_time);

		motor[port1] = speed;
		motor[port10] = -speed;

	}

	else if ((SensorValue(limitBack1) == 1) && (SensorValue(limitBack2) == 0)) {
		motor[port1] = -speed;
		motor[port10] = speed;
		wait1Msec(reverse_time);

		motor[port1] = speed;
		motor[port10] = speed;
		wait1Msec(spin_time);

		motor[port1] = speed;
		motor[port10] = -speed;
	}

	else {
		motor[port1] = -speed;
		motor[port10] = speed;
		wait1Msec(reverse_time+1);

		motor[port1] = speed;
		motor[port10] = speed;
		wait1Msec(spin_time);

		motor[port1] = speed;
		motor[port10] = -speed;
	}
}


task main()
{
	int state;

	freq = 0; // 0 = 1khz (red) 1 = 10khz (green)
	ambient_level = 200; // used in 'move'
	slow_level = 5000;
	stop_level = 6000;
	expose_time = 5; // expose time was changed from 3ms to 5ms (3ms in easyC -> 5ms in RobotC)
	steer_sensitivity = 20;
	forward_speed = 35;
	backward_speed = -35;
	slow_speed = 25;
	spin_speed = 50;

	SensorValue[digital10] = freq;// turn to 1KHz(red beacon)

	/*state 1 = find red
	state 2 = turn off red
	state 3 = find green
	state 4 = kidnap green
	state 5 = leave arena */

	state = 1;

	while(state == 1) { //finding red
		armUp();
		goToBeacon();
		state = 2;
	}

	while (state == 2) { //turning off red
		while ((SensorValue(limit) == 1) && (PD_sum > ambient_level)) {
			motor[port1] = 0;
			motor[port10] = 0;
			moveArm();
			ReadPD();
		}

		state = 3;
	}

	while (state == 3) { //finding green
		freq = 1;
		SensorValue[digital10] = freq;

		armUp();
		goToBeacon();

		if (SensorValue(limit) == 1) {
			state = 4;
		}
	}

	while (state == 4) { //kidnapping green
		armDown();
		motor[port2] = 0;

		state = 5;
	}

	while (state == 5) { //leaving arena
		escape();
	}


}
